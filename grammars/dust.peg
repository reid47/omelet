{
    var util = {};
    util.typeOf = function(obj, noGenerics) {
        var t = ({}).toString.call(obj).match(/\s([a-z|A-Z]+)/)[1];
        if (t !== "Object") {
            if (t === "Array") {
                if (noGenerics) return "Array";
                var t0 = util.typeOf(obj[0]);
                for (var i=0; i<obj.length; i++) {
                    if (t0 !== util.typeOf(obj[i])) {
                        t0 = "Dynamic";
                        break;
                    }
                }
                return "Array<"+t0+">";
            } else {
                return t;
            }
        }
        return obj.constructor.name;
    }
}

Document = contents:Content
    {
        return {
            kind: "Document",
            contents: contents
        }
    }

Content
    = (DustExpression / Doctype / Comment / RawTag / Tag / Text)*

DustExpression
    = Key

Identifier
    = id:([a-zA-Z] [a-zA-Z0-9_-]*)
    {
        return {
            kind: "Identifier",
            value: id[0].concat(id[1].join(""))
        }
    }

Filter
    = "|" id:Identifier
    {
        return {
            kind: "Filter",
            name: id,
            arguments: []
        }
    }

Key
    = "{" id:Identifier filters:Filter* "}"
    {
        return {
            kind: "Interpolation",
            value: id,
            arguments: [],
            filters: filters
        }
    }

Section
    = "{#" openName:Identifier "}" contents:Content "{/" closeName:Identifier "}"
    {
        if (openName.value !== closeName.value) {
            throw SyntaxError("Missing closing tag for section "+openName.value);
        }
        //really unsure if this will work - do we need closures?
        return {
            kind: "InternalConditional",
            predicate: util.typeOf(evalExpr(openName),false) === "Array",
            thenCase: {
                kind: "ForEach",
                iterator: ".",
                data: openName,
                body: contents
            },
            elseCase: {

            }
        }
    }

/* EVERYTHING BELOW THIS LINE IS BASIC HTML */

RawTag
    = ScriptTag / StyleTag

ScriptTag
    = "<script"i _ attrs:(Attribute _)* ">" s:(!"</script>"i s:. {return s})* "</script>"i
    {
        return {
            kind: "Tag",
            name: "script",
            attributes: attrs.map(function(a) { return a[0] }),
            inner: {
                kind: "Raw",
                value: s.join("")
            }
        }
    }

StyleTag
    = "<style"i _ attrs:(Attribute _)* ">" s:(!"</style>"i s:. {return s})* "</script>"i
    {
        return {
            kind: "Tag",
            name: "style",
            attributes: attrs.map(function(a) { return a[0] }),
            inner: {
                kind: "Raw",
                value: s.join("")
            }
        }
    }

Doctype
    = "<!DOCTYPE "i _ doctype:[^\>]+ _ ">"
    {
        return {
            kind: "Doctype",
            value: doctype.join("").trim()
        }
    }

VoidTag
    = "<" tagName:TagName _ attrs:(Attribute _)* "/>"
    {
        return {
            kind: "Tag",
            name: tagName,
            attributes: attrs.map(function(a) { return a[0] }),
            inner: []
        }
    }

Tag
    = VoidTag
    / openTag:OpenTag inner:Content closeTag:CloseTag
    {
        if (openTag.value !== closeTag.value) {
            throw SyntaxError("Missing closing tag for element "+openTag.value);
        }
        return {
            kind: "Tag",
            name: openTag.value,
            attributes: openTag.attributes,
            inner: inner
        }
    }

OpenTag
    = "<" tagName:TagName _ attrs:(Attribute _)* ">"
    {
        return {
            kind: "String",
            value: tagName,
            attributes: attrs.map(function(a) { return a[0] })
        }
    }

CloseTag
    = "</" tagName:TagName _ ">"
    {
        return {
            kind: "String",
            value: tagName
        }
    }

AttributeName
    = attrName:[^ \t\n\r\"\'\>\/\=]+
    {
        return {
            kind: "String",
            value: attrName.join("")
        }
    }

UnquotedAttributeValue
    = attrValue:[^ \t\n\r\"\'\=\<\>\`]+
    {
        return {
            kind: "String",
            value: attrValue.join("")
        }
    }

QuotedAttributeValue
    = attrValue:( "'" [^\']* "'" / '"' [^\"]* '"')
    {
        return {
            kind: "String",
            value: attrValue[1].join("")
        }
    }

EmptyAttribute
    = attrName:AttributeName
    {
        return {
            kind: "Attribute",
            name: attrName,
            value: attrName
        }
    }

UnquotedAttribute
    = attrName:AttributeName _ "=" _ attrValue:UnquotedAttributeValue
    {
        return {
            kind: "Attribute",
            name: attrName,
            value: attrValue
        }
    }

QuotedAttribute
    = attrName:AttributeName _ "=" _ attrValue:QuotedAttributeValue
    {
        return {
            kind: "Attribute",
            name: attrName,
            value: attrValue
        }
    }

Attribute
    = QuotedAttribute / UnquotedAttribute / EmptyAttribute

TagName
    = tagName:([a-zA-Z0-9\_\-\:]*)
    {
        return tagName.join("")
    }

Text
    = text:[^\<\>{]+
    {
        return {
            kind: "String",
            value: text.join("")
        }
    }

Comment
    = "<!--" c:(!"-->" c:. {return c})* "-->"
    {
        return {
            kind: "CommentHTML",
            value: c.join("")
        }
    }

_ "whitespace"
    = [ \t\n\r]*