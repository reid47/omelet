{
    function isArray(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    }
    function mergeAttributes(attrList,attrName) {
        if (attrList.length < 2) return attrList;

        var toMerge = [];
        var indices = [];

        for (var i=0; i<attrList.length; i++) {
            if (attrList[i].name.value === attrName) {
                toMerge.push(attrList[i]);
                indices.push(i);
            }
        }

        if (toMerge.length == 0) return attrList;

        var newAttrVal = "";
        for (var i=0; i<toMerge.length; i++) {
            newAttrVal += toMerge[i].value.value + " ";
        }
        newAttrVal = newAttrVal.trim();
        toMerge[0].value.value = newAttrVal;

        for (var i=1; i<toMerge.length; i++) {
            attrList.splice(indices[i],1);
        }

        return attrList;
    }

    var reserved = {
        "for": true, "if": true, "elif": true, "else": true,
        "include": true, "import": true, "extend": true
    }
}

Document = _ top:(Comment / Extend / Import)* content:Content
{
    var comments = []
    var extend = null
    var imports = []
    var importHasAppeared = false
    for (var i=0; i<top.length; i++) {
        if (top[i].kind === "Comment") {
            comments.push(top[i])
        } else if (top[i].kind === "Extend") {
            if (extend === null) {
                if (!importHasAppeared) {
                    extend = top[i]
                } else {
                    throw SyntaxError("Extend statement must come before any import statements.")
                }
            } else {
                throw SyntaxError("Only one extend statement allowed per document. This document already extends '"+ext.file.value+"'.")
            }
        } else if (top[i].kind === "Import") {
            importHasAppeared = true
            imports.push(top[i])
        }
    }

    return {
        kind: "Document",
        extend: extend,
        imports: imports,
        contents: comments.concat(content),
        //location: location()
    }
}

Content
    = Expression*

Expression
    = Comment / MultiLineString / For / If / Include / Definition / Doctype / Tag / Interpolation / Text

Block
    = elements:(Comment / MultiLineString / For / If / Include / Doctype / Tag / Interpolation / Text)*
    {
        return {
            kind: "Block",
            contents: elements,
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// TOP-LEVEL STATEMENTS
// (extend, import)
//--------------------------------------------------------------------------

Extend "an extend statement"
    = ">extend" __ file:Path __ extra:([^\n])* "\n" _
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of extend statement. An extend statement must appear on a line by itself.")
        }
        return {
            kind: "Extend",
            file: file,
            //location: location()
        }
    }

Import "an import statement"
    = ">import" __ file:Path __ alias:("as" __ Identifier)? __ extra:([^\n])* "\n" _
    {
        if (alias === null) {
            throw SyntaxError("Invalid import statement. You must provide an alias, like this: >import " + file.value + " as someAlias")
        }
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of import statement. An import statement must appear on a line by itself.")
        }
        return {
            kind: "Import",
            file: file,
            alias: alias[2],
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// FOR LOOPS
// (& related things)
//--------------------------------------------------------------------------

For "a for loop"
    = ">for " __ iterator:Identifier __ "in" __ data:(Identifier / Path) __ extra:([^\n\|]*) filters:("|" __ Filter)* "\n" body:(Indent Block Dedent)
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of for loop header. If you meant to add a filter, precede this text with a '|' character.")
        }
        return {
            kind: "For",
            iterator: iterator,
            data: data,
            filters: filters.length === 0 ? null :
                {
                    kind: "FilterSequence",
                    sequence: filters.map(function(f) { return f[2] }),
                    //location: location()
                },
            body: body[1],
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// IF / ELIF / ELSE
// (& related things)
//--------------------------------------------------------------------------

If "an if statement"
    = ">if " __ not:"not "? __ predicate:(IdentifierComplex / Identifier) __ extra:([^\n\|]*) filters:("|" __ Filter)* "\n"
        thenCase:(Indent Block Dedent)?
        elifCases:Elif*
        elseCase:Else?
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of if statement. If you meant to add a filter, precede this text with a '|' character.")
        }
        return {
            kind: "If",
            predicate: predicate,
            negated: not !== null,
            filters: filters.length === 0 ? null :
                {
                    kind: "FilterSequence",
                    sequence: filters.map(function(f) { return f[2] }),
                    //location: location()
                },
            thenCase: thenCase === null ? null : thenCase[1],
            elifCases: elifCases,
            elseCase: elseCase,
            //location: location()
        }
    }

Elif "an elif case"
    = ">elif " __ not:"not "? __ predicate:(IdentifierComplex / Identifier) __ extra:([^\n\|]*) filters:("|" __ Filter)* "\n"
        __ body:(Indent Block Dedent)?
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of elif statement. If you meant to add a filter, precede this text with a '|' character.")
        }
        return {
            kind: "IfStatement",
            predicate: predicate,
            negated: not !== null,
            thenCase: body === null ? null : body[1]
        }
    }

Else "an else case"
    = ">else" __ extra:([^\n\|]*) "\n" __ body:(Indent Block Dedent)?
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of elif statement. If you meant to add a filter, precede this text with a '|' character.")
        }
        return body === null ? null : body[1]
    }

//--------------------------------------------------------------------------
// INCLUDES & MACRO CALLS
// (>include /file with, >macro with, etc.)
//--------------------------------------------------------------------------

Include "an include"
    = ">include " __ path:Path __
        context:("with" Indent Definition* Dedent)?
    {
        if (path.kind === "Identifier") {
            throw SyntaxError("Invalid include statement '>include "+path.value+"'. To include a variable, use '>"+path.value+"'.")
        }
        return {
            kind: "Include",
            included: path,
            context: context === null ? null : context[2],
            //location: location()
        }
    }
    / ">"__ id:(IdentifierComplex / Identifier) __
        context:("with" Indent Definition* Dedent)?
    {
        if (id.value === "include") {
            throw SyntaxError("Invalid include statement '>include'. You must give a path to the included file.")
        }
        return {
            kind: "Include",
            included: id,
            context: context === null ? null : context[2],
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// DEFINITIONS
// (block defs, line defs, array element lists)
//--------------------------------------------------------------------------

Definition "a definition"
    = def:(BlockDefinition / LineDefinition)
    {
        if (reserved[def.name.value]) {
            throw SyntaxError("Illegal definition: Cannot assign a value to reserved word '"+def.name.value+"'.")
        }
        return def
    }

LineDefinition
   // = "+" __ name:Identifier __ params:(Identifier __)* "=" __ body:(Number / QuotedString / Boolean / LineTag / LineOfText)? __ "\n" _
    = "+" __ name:Identifier __ params:(Identifier __)* "=" __ body:(Number __ "\n" / MultiLineString __ "\n" / QuotedString __ "\n" / Boolean __ "\n" / LineTag __ "\n" / LineOfText __ "\n")? _
    {
        if (body === null) {
            throw SyntaxError("Incomplete definition of " + name.value + ".")
        }
        params = params.map(function(a) { return a[0] })
        if (params.length > 0 && body[0].kind !== "Block") {
            throw SyntaxError("Invalid definition '+ "+
                                name.value+" "+params.map(function(p){return p.value}).join(" ")+" ="+
                                "'. Parameters are not allowed in definitions where the right side is not a Block. The given right side is a "+body.kind+".")
        }
        return {
            kind: "Definition",
            name: name,
            parameters: params,
            body: body[0],
            //location: location()
        }
    }

BlockDefinition
    = "+" __ name:Identifier __ params:(Identifier __)* "=" __ body:(Indent ArrayElementList Dedent)
    {
        if (params.length > 0) {
            throw SyntaxError("Invalid definition '+ "+
                                name.value+" "+params.map(function(p){return p[0].value}).join(" ")+" ="+
                                "'. Parameters are not allowed in definitions where the right side is not a Block. The given right side is an Array.")
        }
        return {
            kind: "Definition",
            name: name,
            parameters: [],
            body: {
                kind: "Array",
                elements: body[1]
            },
            //location: location()
        }
    }
    / "+" __ name:Identifier __ params:(Identifier __)* "=" __ body:(Indent Definition* Dedent)
    {
        if (params.length > 0) {
            throw SyntaxError("Invalid definition '+ "+
                                name.value+" "+params.map(function(p){return p[0].value}).join(" ")+" ="+
                                "'. Parameters are not allowed in definitions where the right side is not a Block. The given right side is a Dictionary.")
        }
        return {
            kind: "Definition",
            name: name,
            parameters: [],
            body: {
                kind: "Dictionary",
                entries: body[1]
            },
            //location: location()
        }
    }
    / "+" __ name:Identifier __ params:(Identifier __)* "=" body:(Indent Block Dedent)
    {
        return {
            kind: "Definition",
            name: name,
            parameters: params.map(function(a) { return a[0] }),
            body: body === null ? body : body[1],
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// ARRAYS
// (array element lists, line elements, block elements)
//--------------------------------------------------------------------------

ArrayElementList
    = (LineArrayElement / BlockArrayElement)*

LineArrayElement
    = __ "-" " "? value:(Number / QuotedString / Boolean) "\n"
    {
        return {
            kind: "ArrayElement",
            value: value,
            //location: location()
        }
    }

BlockArrayElement
    = __ "-" body:(Indent ArrayElementList Dedent)
    {
        return {
            kind: "ArrayElement",
            value: {
                kind: "Array",
                elements: body[1]
            },
            //location: location()
        }
     }
     / __ "-" body:(Indent Content Dedent)
     {
        for (var i=0; i<body[1].length; i++) {
            if (!body[1][i].kind || body[1][i].kind !== "Definition")
                throw SyntaxError("Invalid definition for dictionary. Dictionaries must be composed entirely of key/value pairs.")
        }
        return {
            kind: "ArrayElement",
            value: {
                kind: "Dictionary",
                entries: body[1],
                //location: location()
            },
            //location: location()
        }
     }

//--------------------------------------------------------------------------
// INTERPOLATION & FILTERS
// (interpolations, filters, filter arguments, arguments)
//--------------------------------------------------------------------------

Interpolation
    = "{" openTag:OpenTag contents:(Text / Interpolation)* "}"
    {
        if (isArray(openTag)) {
            var o = {
                kind: "Tag",
                name: openTag[0].value,
                attributes: mergeAttributes(openTag[0].attributes,"class"),
                //location: location()
            };
            var curr = o;
            for (var i=1; i<openTag.length; i++) {
                curr.inner = {
                    kind: "Block",
                    contents: [{
                        kind: "Tag",
                        name: openTag[i].value,
                        attributes: mergeAttributes(openTag[i].attributes,"class"),
                        //location: location()
                    }],
                    //location: location()
                }
                curr = curr.inner.contents[0];
            }
            curr.inner = {
                kind: "Block",
                contents: contents,
                //location: location()
            }
            return o;
        } else {
            return {
                kind: "Tag",
                name: openTag.value,
                attributes: mergeAttributes(openTag.attributes,"class"),
                inner: {
                    kind: "Block",
                    contents: contents,
                    //location: contents.length > 0 ? contents[0].location : location()
                },
                //location: location()
            }
        }
    }
    / "{" " "? id:(IdentifierComplex / Identifier) args:ArgumentList? __ filters:("|" __ Filter)* "}"
    {
        filters = filters.map(function(f) { return f[2] })
        return {
            kind: "Interpolation",
            name: id,
            positionalArgs: true,
            context: null,
            arguments: args === null ? [] : args,
            filters: filters.length === 0 ? null : {
                kind: "FilterSequence",
                sequence: filters,
                //location: {
                //  start: filters[0].location.start,
                //    end: filters[filters.length-1].location.end
                //}
            },
            //location: location()
        }
    }

FilterArgument "a filter argument"
    = __ "(" filter0:Filter? filters:("|" __ Filter)* ")"
    {
        filter0 = filter0 === null ? [] : [filter0]
        filters = filters.map(function(f) { return f[2] })
        return {
            kind: "FilterSequence",
            sequence: filter0.concat(filters),
            //location: location()
        }
    }
    / __ arg:Argument
    {
        return arg
    }

Filter "a filter"
    = name:Identifier args:FilterArgument* __
    {
        return {
            kind: "Filter",
            name: name,
            arguments: args,
            //location: location()
        }
    }

Argument "an argument"
    = QuotedString / Number / Boolean / IdentifierComplex / Identifier

ArgumentList
    = " " first:Argument __ rest:(__ Argument)*
    {
        var newRest = rest.map(function(a) { return a[1] });
        return [first].concat(newRest);
    }

//--------------------------------------------------------------------------
// IDENTIFIERS
// (identifiers, modifiers)
//--------------------------------------------------------------------------

Identifier
    = id:([\$_a-zA-Z] [a-zA-Z0-9_\-\$]*)
    {
        return {
            kind: "Identifier",
            value: id[0].concat(id[1].join("")),
            modifiers: [],
            //location: location()
        }
    }

IdentifierComplex
    = ident:Identifier mods:Modifier+
    {
        ident.modifiers = mods
        return ident
    }

Modifier
    = ("." mod:Identifier)
    {
        mod.kind = "String"
        return {
            kind: "Modifier",
            value: mod,
            //location: location()
        }
    }
    / ("[" mod:(Number / QuotedString) "]")
    {
        return {
            kind: "Modifier",
            value: mod,
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// HTML
// (tags, attributes, doctypes)
//--------------------------------------------------------------------------

Tag "a tag"
    = RawTag / LineTag / BlockTag

RawTag
    = openTag:OpenTag __ raw:MultiLineString
    {
        if (isArray(openTag)) {
            var o = {
                kind: "Tag",
                name: openTag[0].value,
                attributes: mergeAttributes(openTag[0].attributes,"class"),
                //location: location()
            }
            var curr = o
            for (var i=1; i<openTag.length; i++) {
                curr.inner = {
                    kind: "Block",
                    contents: [{
                        kind: "Tag",
                        name: openTag[i].value,
                        attributes: mergeAttributes(openTag[i].attributes,"class"),
                        //location: location()
                    }],
                    //location: location()
                }
                curr = curr.inner.contents[0]
            }
            curr.inner = raw;

            return o;
        } else {
            return {
                kind: "Tag",
                name: openTag.value,
                attributes: mergeAttributes(openTag.attributes,"class"),
                inner: raw
            }
        }
    }

LineTag
    = openTag:OpenTag __ line:LineOfText "\n" __ !Indent
    {
        if (isArray(openTag)) {
            var o = {
                kind: "Tag",
                name: openTag[0].value,
                attributes: mergeAttributes(openTag[0].attributes,"class")
                //location: location()
            }
            var curr = o
            for (var i=1; i<openTag.length; i++) {
                curr.inner = {
                    kind: "Block",
                    contents: [{
                        kind: "Tag",
                        name: openTag[i].value,
                        attributes: mergeAttributes(openTag[i].attributes,"class"),
                        //location: location()
                    }],
                    //location: location()
                }
                curr = curr.inner.contents[0]
            }
            curr.inner = line
            return o;
        } else {

            return {
                kind: "Tag",
                name: openTag.value,
                attributes: mergeAttributes(openTag.attributes,"class"),
                inner: line,
                //location: location()
            }
        }
    }

BlockTag
    = openTag:OpenTag inner:(Indent Block Dedent)
    {
        if (isArray(openTag)) {
            var o = {
                kind: "Tag",
                name: openTag[0].value,
                attributes: mergeAttributes(openTag[0].attributes,"class"),
                //location: location()
            }
            var curr = o
            for (var i=1; i<openTag.length; i++) {
                curr.inner = {
                    kind: "Block",
                    contents: [{
                        kind: "Tag",
                        name: openTag[i].value,
                        attributes: mergeAttributes(openTag[i].attributes,"class"),
                        //location: location()
                    }],
                    //location: location()
                }
                curr = curr.inner.contents[0]
            }
            curr.inner = inner === null ? [] : inner[1]
            return o
        } else {
            return {
                kind: "Tag",
                name: openTag.value,
                attributes: mergeAttributes(openTag.attributes,"class"),
                inner: inner === null ? [] : inner[1],
                //location: location()
            }
        }
    }

OpenTag
    = "@" first:SingleTag rest:("|" SingleTag)+ " "?
    {
        var newRest = rest.map(function(a) { return a[1]; });
        return [first].concat(newRest)
    }
    / "@" single:SingleTag " "?
    {
        return single
    }

SingleTag
    = tagName:TagName specialAttrs:SpecialAttribute* attrList:AttributeList?
    {
        var attrs = specialAttrs;
        attrs = attrList === null ? specialAttrs : specialAttrs.concat(attrList);
        return {
            kind: "String",
            value: tagName,
            attributes: attrs,
            //location: location()
        }
    }

TagName "a tag name"
    = tagName:([a-zA-Z] [a-zA-Z0-9\_\-\:]*)
    {
        return {
            kind: "String",
            value: tagName[0].concat(tagName[1].join("")),
            //location: location()
        }
    }

AttributeList
    = "[" attrs:(Attribute _)+ "]"
    { return attrs.map(function(a) { return a[0] }) }

Attribute "an attribute"
    = InterpolatedAttribute
    / QuotedAttribute
    / UnquotedAttribute
    / EmptyAttribute

InterpolatedAttribute
    = attrName:AttributeName _ "=" _ attrValue:Interpolation
    {
        return {
            kind: "Attribute",
            name: attrName,
            value: attrValue,
            //location: location()
        }
    }

QuotedAttribute
    = attrName:AttributeName _ "=" _ attrValue:QuotedString
    {
        return {
            kind: "Attribute",
            name: attrName,
            value: attrValue,
            //location: location()
        }
    }

UnquotedAttribute
    = attrName:AttributeName _ "=" _ attrValue:UnquotedAttributeValue
    {
        return {
            kind: "Attribute",
            name: attrName,
            value: attrValue,
            //location: location()
        }
    }

EmptyAttribute
    = attrName:AttributeName
    {
        return {
            kind: "Attribute",
            name: attrName,
            value: attrName,
            //location: location()
        }
    }

/* TODO: single colons should be allowed here */
AttributeName
    = attrName:[^ \t\n\r\"\'\>\/\=\)\(\[\]\:]+
    {
        return {
            kind: "String",
            value: attrName.join(""),
            //location: location()
        }
    }

UnquotedAttributeValue
    = attrValue:[^ \t\n\r\"\'\=\<\>\`\,\.\]]+
    {
        return {
            kind: "String",
            value: attrValue.join(""),
            //location: location()
        }
    }

SpecialAttribute
    = ClassAttribute / IdAttribute

ClassAttribute
    = "." className:CSSSelectorString
    {
        return {
            kind: "Attribute",
            name: {
                kind: "String",
                value: "class",
                //location: location()
            },
            value: className,
            //location: location()
        }
    }

IdAttribute
    = "#" id:CSSSelectorString
    {
        return {
            kind: "Attribute",
            name: {
                kind: "String",
                value: "id",
                //location: location()
            },
            value: id,
            //location: location()
        }
    }

CSSSelectorString
    = id:([\$a-zA-Z] [a-zA-Z0-9_-]*)
    {
        return {
            kind: "String",
            value: id[0].concat(id[1].join("")),
            //location: location()
        }
    }

Doctype
    = "@doctype " __ name:([^\n])+ "\n" _
    {
        return {
            kind: "Doctype",
            name: {
                kind: "String",
                value: name.join(""),
                //location: location()
            },
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// LITERALS
// (quoted strings, numbers, booleans, comments)
//--------------------------------------------------------------------------

Path "a path to a file or directory"
    = prefix:"/"?
      part0:([a-zA-Z0-9-_\.]+)
      parts:("/" ([a-zA-Z0-9_\.]+))*
      ext:("." [a-zA-Z0-9]+)?
      final:"/"?
    {
        prefix = prefix === null ? "" : prefix
        final = final === null ? "" : final
        ext = ext === null ? "" : "."+ext[1].join("");
        var path = prefix + [part0.join("")]
                    .concat(parts.map(function(a){return "/"+a[1].join("")}))
                    .join("") + ext + final
        return {
            kind: "Path",
            value: path,
            //location: location()
        }
    }

QuotedString
    = MultiLineString
    / value:( "'" [^\']* "'" / '"' [^\"]* '"')
    {
        return {
            kind: "String",
            quoted: true,
            value: value[1].join(""),
            //location: location()
        }
    }

MultiLineString
    = '"""' noEscape:"~"? r:(!'"""' r:. {return r})* '"""'
    {
        return {
            kind: "String",
            noEscape: noEscape !== null,
            value: r.join("").replace(/\n[⇐⇒]/g,"").replace(/\"/g,"\\\""),
            //location: location()
        }
    }

Number "a number"
    = minus:"-"? integer:[0-9]+ decimal:("." [0-9]+)?
    {
        var value;
        if (decimal === null) {
            value = parseInt(integer.join(""));
        } else {
            value = parseFloat(integer.join("")+"."+decimal[1].join(""))
        }
        if (minus !== null) {
            value = 0-value;
        }
        return {
            kind: "Number",
            value: value,
            //location: location()
        }
    }

Boolean "a boolean value"
    = value:("true" / "false")
    {
        return {
            kind: "Boolean",
            value: value === "true",
            //location: location()
        }
    }

Comment "a comment"
    = LineComment //possible todo: block comments

LineComment
    = "##" value:[^\n]* "\n" _
    {
        return {
            kind: "Comment",
            value: value.join(""),
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// MISCELLANEOUS
// (indents, whitespace)
//--------------------------------------------------------------------------

Indent "an indent"
    = _ "⇒" _

Dedent "a dedent"
    = _ "⇐" _

_ "whitespace"
    = [ \t\n\r]*
__
    = [ ]*

//--------------------------------------------------------------------------
// TEXT & SPECIAL CHARACTERS
//--------------------------------------------------------------------------

LineOfText
    = things:(TextWithoutNewlines / Interpolation)*
    {
        /*var line = [text];
        for (var i=0; i<other.length; i++) {
            line.push(other[i][0]);
            line.push({
                kind: "String",
                value: other[i][1].join(""),
                //location: location()
            });
        }*/
        return {
            kind: "Block",
            contents: things,
            //location: location()
        };
    }

TextWithoutNewlines "plain text"
    = text:[^\n⇐⇒@{\\#\+]+
    {
        return {
            kind: "String",
            value: text.join(""),
            //location: location()
        }
    }
    / EscapedCharacter

Text "plain text"
    = text:[^⇐⇒@{\\#\+]+
    {
        return {
            kind: "String",
            value: text.join(""),
            //location: location()
        }
    }
    / EscapedCharacter

EscapedCharacter
    = "\\" char:([{@\\#>])
    {
        return {
            kind: "String",
            value: char ? char : "\\",
            //location: location()
        }
    }
    / "#" !"#"
    {
        return {
            kind: "String",
            value: "#",
            //location: location()
        }
    }
    / "+" !(Identifier __ "=")
    {
        return {
            kind: "String",
            value: "+",
            //location: location()
        }
    }

