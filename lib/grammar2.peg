{
    function isArray(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    }
    function mergeAttributes(attrList,attrName) {
        if (attrList.length < 2) return attrList;

        var toMerge = [];
        var indices = [];

        for (var i=0; i<attrList.length; i++) {
            if (attrList[i].name.value === attrName) {
                toMerge.push(attrList[i]);
                indices.push(i);
            }
        }

        if (toMerge.length == 0) return attrList;

        var newAttrVal = "";
        for (var i=0; i<toMerge.length; i++) {
            newAttrVal += toMerge[i].value.value + " ";
        }
        newAttrVal = newAttrVal.trim();
        toMerge[0].value.value = newAttrVal;

        for (var i=1; i<toMerge.length; i++) {
            attrList.splice(indices[i],1);
        }

        return attrList;
    }

    var reserved = {
        "for": true,
        "if": true,
        "elif": true,
        "else": true,
        "include": true,
        "import": true,
        "extend": true
    }
}

Document = top:(Comment / Extend / Import)* content:Content
{
    var comments = []
    var extend = null
    var imports = []
    var importHasAppeared = false
    for (var i=0; i<top.length; i++) {
        if (top[i].kind === "Comment") {
            comments.push(top[i])
        } else if (top[i].kind === "Extend") {
            if (extend === null) {
                if (!importHasAppeared) {
                    extend = top[i]
                } else {
                    throw SyntaxError("Extend statement must come before any import statements.")
                }
            } else {
                throw SyntaxError("Only one extend statement allowed per document. This document already extends '"+ext.file.value+"'.")
            }
        } else if (top[i].kind === "Import") {
            importHasAppeared = true
            imports.push(top[i])
        }
    }

    return {
        kind: "Document",
        extend: extend,
        imports: imports,
        contents: comments.concat(content),
        //location: location()
    }
}

Content
    = Expression*

Expression
    = Comment / For / Definition / Doctype / Interpolation / Text

//--------------------------------------------------------------------------
// TOP-LEVEL STATEMENTS
// (extend, import)
//--------------------------------------------------------------------------

Extend "an extend statement"
    = ">extend" __ file:Path __ extra:([^\n])* "\n" _
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of extend statement. An extend statement must appear on a line by itself.")
        }
        return {
            kind: "Extend",
            file: file,
            //location: location()
        }
    }

Import "an import statement"
    = ">import" __ file:Path __ "as" __ alias:Identifier __ extra:([^\n])* "\n" _
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of import statement. An import statement must appear on a line by itself.")
        }
        return {
            kind: "Import",
            file: file,
            alias: alias,
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// FOR LOOPS
// (& related things)
//--------------------------------------------------------------------------

For "a for loop"
    = ">for" __ iterator:Identifier __ "in" __ data:(Identifier / Path) __ extra:([^\n\|]*) filters:("|" __ Filter)* "\n" body:(Indent Block Dedent)
    {
        if (extra.length > 0) {
            throw SyntaxError("Invalid characters '"+extra.join("")+"' found at end of for loop header. If you meant to add a filter, precede this text with a '|' character.")
        }
        return {
            kind: "For",
            iterator: iterator,
            data: data,
            filters: filters.length === 0 ? null :
                filters.map(function(f) { return f[2] }),
            body: body[1],
            //location: location()
        }
    }

Block
    = elements:(Comment / Interpolation / For / Text)*
    {
        return {
            kind: "Block",
            contents: elements,
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// DEFINITIONS
// (block defs, line defs, array element lists)
//--------------------------------------------------------------------------

Definition "a definition"
    = def:(BlockDefinition / LineDefinition)
    {
        if (reserved[def.name.value]) {
            throw SyntaxError("Illegal definition: Cannot assign a value to reserved word '"+def.name.value+"'.")
        }
        return def
    }

LineDefinition
    = "+" __ name:Identifier __ params:(Identifier __)* "=" __ body:(Number / QuotedString / Boolean)? __ "\n" _
    {
        params = params.map(function(a) { return a[0] })
        if (params.length > 0 && body.kind !== "Block") {
            throw SyntaxError("Invalid definition '+ "+
                                name.value+" "+params.map(function(p){return p.value}).join(" ")+" ="+
                                "'. Parameters are not allowed in definitions where the right side is not a Block. The given right side is a "+body.kind+".")
        }
        return {
            kind: "Definition",
            name: name,
            parameters: params,
            body: body,
            //location: location()
        }
    }

BlockDefinition
    = "+" __ name:Identifier __ params:(Identifier __)* "=" __ body:(Indent ArrayElementList Dedent)
    {
        if (params.length > 0 && body.kind !== "Block") {
            throw SyntaxError("Invalid definition '+ "+
                                name.value+" "+params.map(function(p){return p.value}).join(" ")+" ="+
                                "'. Parameters are not allowed in definitions where the right side is not a Block. The given right side is an Array.")
        }
        return {
            kind: "Definition",
            name: name,
            parameters: params.map(function(a) { return a[0] }),
            body: {
                kind: "Array",
                elements: body[1]
            },
            //location: location()
        }
    }
    / "+" __ name:Identifier __ params:(Identifier __)* "=" __ body:(Indent Content Dedent)
    {
        if (params.length > 0 && body.kind !== "Block") {
            throw SyntaxError("Invalid definition '+ "+
                                name.value+" "+params.map(function(p){return p.value}).join(" ")+" ="+
                                "'. Parameters are not allowed in definitions where the right side is not a Block. The given right side is a Dictionary.")
        }
        return {
            kind: "Definition",
            name: name,
            parameters: params.map(function(a) { return a[0] }),
            body: {
                kind: "Dictionary",
                entries: body[1]
            },
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// ARRAYS
// (array element lists, line elements, block elements)
//--------------------------------------------------------------------------

ArrayElementList
    = (LineArrayElement / BlockArrayElement)*

LineArrayElement
    = __ "-" " "? value:(Number / QuotedString / Boolean) "\n"
    {
        return {
            kind: "ArrayElement",
            value: value,
            //location: location()
        }
    }

BlockArrayElement
    = __ "-" body:(Indent ArrayElementList Dedent)
    {
        return {
            kind: "ArrayElement",
            value: {
                kind: "Array",
                elements: body[1]
            },
            //location: location()
        }
     }
     / __ "-" body:(Indent Content Dedent)
     {
        for (var i=0; i<body[1].length; i++) {
            if (!body[1][i].kind || body[1][i].kind !== "Definition")
                throw SyntaxError("Invalid definition for dictionary '"+name.value+"'. Dictionaries must be composed entirely of key/value pairs.")
        }
        return {
            kind: "ArrayElement",
            value: {
                kind: "Dictionary",
                entries: body[1],
                //location: location()
            },
            //location: location()
        }
     }

//--------------------------------------------------------------------------
// INTERPOLATION & FILTERS
// (interpolations, filters, filter arguments, arguments)
//--------------------------------------------------------------------------

Interpolation
    = "{" " "? id:(Path / IdentifierComplex / Identifier) " "? __ filters:("|" __ Filter)* "}"
    {
        return {
            kind: "Interpolation",
            name: id,
            filters: filters.length === 0 ? null : {
                kind: "FilterSequence",
                sequence: filters.map(function(f) { return f[2] }),
                //location: location() //TODO: close, but not accurate
            },
            //location: location()
        }
    }

FilterArgument "a filter argument"
    = __ "(" filter0:Filter? filters:("|" __ Filter)* ")"
    {
        filter0 = filter0 === null ? [] : [filter0]
        filters = filters.map(function(f) { return f[2] })
        return {
            kind: "FilterSequence",
            sequence: filter0.concat(filters),
            //location: location()
        }
    }
    / __ arg:Argument
    {
        return arg
    }

Filter "a filter"
    = name:Identifier args:FilterArgument* __
    {
        return {
            kind: "Filter",
            name: name,
            arguments: args,
            //location: location()
        }
    }

Argument "an argument"
    = QuotedString / Number / Boolean / IdentifierComplex / Identifier

ArgumentList
    = first:Argument __ rest:("," __ Argument)*
    {
        var newRest = rest.map(function(a) { return a[2] });
        return [first].concat(newRest);
    }

//--------------------------------------------------------------------------
// IDENTIFIERS
// (identifiers, modifiers)
//--------------------------------------------------------------------------

Identifier
    = id:([\$_a-zA-Z] [a-zA-Z0-9_\-\$]*)
    {
        return {
            kind: "Identifier",
            value: id[0].concat(id[1].join("")),
            modifiers: [],
            //location: location()
        }
    }

IdentifierComplex
    = ident:Identifier mods:Modifier+
    {
        ident.modifiers = mods
        return ident
    }

Modifier
    = ("." mod:Identifier)
    {
        return {
            kind: "Modifier",
            value: mod,
            //location: location()
        }
    }
    / ("[" mod:(Number / QuotedString / Identifier) "]")
    {
        return {
            kind: "Modifier",
            value: mod,
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// HTML
// (tags, attributes, doctypes)
//--------------------------------------------------------------------------

Doctype
    = "@doctype " __ name:([^\n])+ "\n" _
    {
        return {
            kind: "Doctype",
            name: {
                kind: "String",
                value: name.join(""),
                //location: location()
            },
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// LITERALS
// (quoted strings, numbers, booleans, comments)
//--------------------------------------------------------------------------

Path "a path to a file or directory"
    = prefix:"/"?
      part0:([a-zA-Z0-9-_\.]+)
      parts:("/" ([a-zA-Z0-9_\.]+))*
      ext:("." [a-zA-Z0-9]+)?
      final:"/"?
    {
        prefix = prefix === null ? "" : prefix
        final = final === null ? "" : final
        ext = ext === null ? "" : "."+ext[1].join("");
        var path = prefix + [part0.join("")]
                    .concat(parts.map(function(a){return "/"+a[1].join("")}))
                    .join("") + ext + final
        return {
            kind: "Path",
            value: path,
            //location: location()
        }
    }

QuotedString
    = value:( "'" [^\']* "'" / '"' [^\"]* '"')
    {
        return {
            kind: "String",
            value: value[1].join(""),
            //location: location()
        }
    }

Number "a number"
    = minus:"-"? integer:[0-9]+ decimal:("." [0-9]+)?
    {
        var value;
        if (decimal === null) {
            value = parseInt(integer.join(""));
        } else {
            value = parseFloat(integer.join("")+"."+decimal[1].join(""))
        }
        if (minus !== null) {
            value = 0-value;
        }
        return {
            kind: "Number",
            value: value,
            //location: location()
        }
    }

Boolean "a boolean value"
    = value:("true" / "false")
    {
        return {
            kind: "Boolean",
            value: value === "true",
            //location: location()
        }
    }

Comment "a comment"
    = LineComment //possible todo: block comments

LineComment
    = "##" value:[^\n]* "\n" _
    {
        return {
            kind: "Comment",
            value: value.join(""),
            //location: location()
        }
    }

//--------------------------------------------------------------------------
// MISCELLANEOUS
// (indents, whitespace)
//--------------------------------------------------------------------------

Indent "an indent"
    = _ "⇒" _

Dedent "a dedent"
    = _ "⇐" _

_ "whitespace"
    = [ \t\n\r]*
__
    = [ ]*

//--------------------------------------------------------------------------
// DEPRECATED?
// (not sure about these, move elsewhere or do not use)
//--------------------------------------------------------------------------

Text "plain text"
    = text:[^⇐⇒@{}\\#]+
    {
        return {
            kind: "String",
            value: text.join("")
        }
    }

