/*
-----------------------------------------------------------------------------
OMELET PARSER

Transforms a list of tokens (generated by lexer) into an AST.
-----------------------------------------------------------------------------

TODO:
- comments between list-items are still weird
    - even if can't allow them, could prob. at least give
      better error messages
- compiler: made some changes to ast spec recently
    - modes
    - tag names now string literals
    - ?? use git to see changes?
- escaped interpolations
*/

var errors = require('./errors.js')
var __ = require('./util.js')

function Parser(tokens, originalCode) {
    this.tokens = tokens
    this.index = 0
    this.line = 1
    this.indentLevel = 0

    this.t = this.tokens[this.index] ||
             {kind: 'eof', value: null, line: -1}
    this.tKind = this.t.kind

    this.originalCode = originalCode || ''

    this.inInterpolation = false
    this.seenNonExtend = false
    this.seenNonImport = false
    this.extendNode = null
    this.importNodes = []
    this.doctypeLine = -1
}

Parser.prototype = {

    constructor: Parser,

    error: function(message, line) {
        var err = errors.buildError(
            'Parser error',
            message,
            (line || this.line),
            this.originalCode)
        throw err
    },

    fail: function() {
        if (this.tKind === 'indent') {
            this.error('Unexpected indent after line ' +
                        this.t.line + '.', this.t.line)
        }
        this.error('Unexpected token \'' + this.tKind +
                     '\' on line ' + this.t.line + '.', this.t.line)
    },

    expect: function(kind) {
        if (this.tKind !== kind) {
            var vowel = /^[aeiou]/
            this.error('Expected a' + (vowel.test(kind) ? 'n' : '') +
                        ' \'' + kind + '\' token, but got a' +
                        (vowel.test(this.tKind) ? 'n' : '') +
                        ' \'' + this.tKind + '\' token.', this.t.line)
        }
    },

    expectOneOf: function(kinds) {
        for (var i = 0; i < kinds.length; i++) {
            if (this.tKind === kinds[i]) {
                return
            }
        }
        var vowel = /^[aeiou]/
        function listify(items) {
            var out = ''
            for (var i = 0; i < items.length; i++) {
                out += vowel.test(items[i]) ? 'an ' : 'a '
                out += '\'' + items[i] + '\''
                if (i < items.length - 2) {
                    out += ', '
                } else if (i === items.length - 2) {
                    out += ', or '
                }
            }
            return out
        }
        this.error('Expected ' + listify(kinds) +
                    ' token, but got a' +
                    (vowel.test(this.tKind) ? 'n' : '') +
                    ' \'' + this.tKind + '\' token.', this.t.line)
    },

    consume: function(n) {
        this.index += n
        this.t = this.tokens[this.index] || {kind: 'eof', value: null, line: -1}
        this.tKind = this.t.kind
    },

    parseDefinition: function() {
        this.consume(1)
        this.disallowModifiers = true

        this.expect('identifier')
        var name = this.parseIdentifier(),
            params = [],
            line = name.line,
            lineEnd = name.lineEnd,
            param, body

        this.expect('begin-params')
        this.consume(1)

        while (param = this.parseIdentifier()) {
            params.push(param)
            lineEnd = param.lineEnd
        }

        this.expect('end-params')
        this.consume(1)

        this.disallowModifiers = false

        if (this.tKind === 'indent') {
            // a block definition!

            body = this.parseList()

            if (!body) {
                body = this.parseBlock()
                lineEnd = body.lineEnd

                // if every node in the body is a definition, then
                // it's a Dictionary (otherwise, it's just some local
                // definitions mixed with other nodes)
                var isDictionary = true
                for (var i = 0; i < body.contents.length; i++) {
                    if (body.contents[i].kind !== 'Definition') {
                        isDictionary = false
                        break
                    }
                }
                if (isDictionary) {
                    body = {
                        kind: 'Dictionary',
                        entries: body.contents,
                        line: body.line,
                        lineEnd: lineEnd
                    }
                }
            }

        } else if (this.tKind === 'number') {
            body = this.parseNumber()
        } else if (this.tKind === 'string') {
            body = this.parseQuotedString()
        } else if (this.tKind === 'boolean') {
            body = this.parseBoolean()
        } else {
            body = []
            while (this.tKind !== 'eof' && this.tKind !== 'newline'
                && this.tKind !== 'indent' && this.tKind !== 'dedent') {
                var node = this.parseToken(this.t)
                body.push(node)
                lineEnd = node.lineEnd
            }
            if (body.length === 0) {
                this.error('Definition of \'' + name.value + '\' is empty.')
            }
            body = {
                kind: 'Block',
                contents: body,
                line: body[0].line,
                lineEnd: lineEnd
            }
        }

        return {
            kind: 'Definition',
            name: name,
            parameters: params,
            body: body,
            line: line,
            lineEnd: body.lineEnd
        }
    },

    parseAttribute: function() {
        if (this.tKind === 'attribute-name') {
            var name = this.t.value,
                line = this.t.line,
                value = this.t.isBooleanAttr
            this.consume(1)
            value = value || this.parseQuotedString() || this.parseInterpolation()
            return {
                kind: 'Attribute',
                name: {
                    kind: 'String',
                    value: name,
                    line: line,
                    lineEnd: line
                },
                value: value,
                line: line,
                lineEnd: line
            }
        }
    },

    parseTag: function() {
        var tagName = this.t.value,
            attributes = [],
            inner = [],
            line = this.t.line
        this.consume(1)

        var attr, classAttr
        while (attr = this.parseAttribute()) {
            var name = attr.name.value
            if (name === 'class') {
                if (classAttr) {
                    classAttr.value.value += ' ' + attr.value.value
                } else {
                    classAttr = attr
                }
            } else {
                attributes.push(attr)
            }
        }
        if (classAttr) {
            attributes.unshift(classAttr)
        }

        var block = this.parseBlock()
        if (block) {
            return {
                kind: 'Tag',
                name: tagName,
                attributes: __.mergeAttributes(attributes),
                tagStyle: 'block',
                inner: block,
                line: line,
                lineEnd: block.contents.length ? block.lineEnd : line
            }
        } else {
            block = []
            var lineEnd
            while (this.tKind !== 'eof' && this.tKind !== 'newline'
                && this.tKind !== 'indent' && this.tKind !== 'dedent') {
                if (this.inInterpolation && this.tKind === 'end-interpolation') {
                    break
                }
                var node = this.parseToken(this.t)
                block.push(node)
                lineEnd = node.lineEnd
            }
            return {
                kind: 'Tag',
                name: tagName,
                attributes: __.mergeAttributes(attributes),
                tagStyle: 'line',
                inner: {
                    kind: 'Block',
                    contents: block,
                    line: block.length ? block[0].line : line,
                    lineEnd: lineEnd || line
                },
                line: line,
                lineEnd: lineEnd || line
            }
        }
    },

    parseText: function() {
        var val = this.t.value,
            line = this.t.line
        this.consume(1)
        return {
            kind: 'String',
            value: val,
            line: line,
            lineEnd: line
        }
    },

    parseDoctype: function() {
        if (this.tKind === 'doctype') {
            if (this.doctypeLine > -1) {
                this.error('Only one doctype is allowed per document. Previous doctype found on line ' + this.doctypeLine + '.', this.t.line)
            } else {
                this.doctypeLine = this.t.line
            }
            var val = this.t.value,
                line = this.t.line
            this.consume(1)
            return {
                kind: 'Doctype',
                name: {
                    kind: 'String',
                    value: val,
                    line: line,
                    lineEnd: line
                },
                line: line,
                lineEnd: line
            }
        }
    },

    parseInterpolation: function() {
        var leaveUnescaped = !!this.t.noEscape

        this.consume(1)

        this.expectOneOf(['identifier', 'tag'])

        if (this.tKind === 'identifier') {
            var name = this.parseIdentifier(),
                args = [],
                filters = null,
                line = name.line,
                lineEnd = name.line,
                arg

            while (arg = (this.parseIdentifier() ||
                          this.parseQuotedString() ||
                          this.parseNumber() ||
                          this.parseBoolean())) {
                args.push(arg)
                lineEnd = arg.line
            }

            filters = this.parseFilterSequence() || null

            this.expect('end-interpolation')
            this.consume(1)

            return {
                kind: 'Interpolation',
                name: name,
                leaveUnescaped: leaveUnescaped,
                positionalArgs: true,
                context: null,
                arguments: args,
                filters: filters,
                line: line,
                lineEnd: filters ? filters.lineEnd : lineEnd
            }
        } else if (this.tKind === 'tag') {

            this.inInterpolation = true
            var tag = this.parseTag()
            tag.tagStyle = 'interpolated'
            this.inInterpolation = false

            this.expect('end-interpolation')
            this.consume(1)

            return tag
        }
    },

    parseFilterSequence: function() {
        if (this.tKind === 'begin-filter-sequence') {
            this.consume(1)

            var filters = [],
                line = this.t.line,
                lineEnd = this.t.line,
                filter

            while (filter = this.parseFilter()) {
                filters.push(filter)
                lineEnd = filter.lineEnd
            }

            this.expect('end-filter-sequence')
            this.consume(1)

            return {
                kind: 'FilterSequence',
                sequence: filters,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    parseFilter: function() {
        if (this.tKind === 'begin-filter') {
            this.consume(1)

            this.expect('identifier')
            var name = this.parseIdentifier(),
                line = name.line,
                lineEnd = name.lineEnd,
                args = [],
                arg

            while (arg = (this.parseNumber() ||
                          this.parseBoolean() ||
                          this.parseQuotedString() ||
                          this.parseIdentifier() ||
                          this.parseFilterSequence())) {
                args.push(arg)
                lineEnd = arg.lineEnd
            }

            this.expect('end-filter')
            this.consume(1)

            return {
                kind: 'Filter',
                name: name,
                arguments: args,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    parseModifier: function() {
        if (this.tKind === 'dot') {
            this.consume(1)
            this.expect('identifier')
            var ident = this.parseIdentifier()
            return {
                kind: 'Modifier',
                value: {
                    kind: 'String',
                    value: ident.value,
                    line: ident.line,
                    lineEnd: ident.lineEnd
                },
                line: ident.line,
                lineEnd: ident.lineEnd
            }
        } else if (this.tKind === 'lbracket') {
            this.consume(1)
            var mod = this.parseIdentifier() ||
                      this.parseNumber() ||
                      this.parseQuotedString()
            this.expect('rbracket')
            this.consume(1)
            return {
                kind: 'Modifier',
                value: mod,
                line: mod.line,
                lineEnd: mod.lineEnd
            }
        }
    },

    parseIdentifier: function() {
        if (this.tKind === 'identifier') {
            var name = this.t.value,
                line = this.t.line,
                lineEnd = this.t.line,
                modifiers = [],
                modifier

            this.consume(1)

            while (modifier = this.parseModifier()) {
                if (this.disallowModifiers) {
                    this.error('Unexpected modifier \'' + modifier.value.value +
                            '\' found on left side of \'=\' in definition.', line)
                }
                modifiers.push(modifier)
            }

            return {
                kind: 'Identifier',
                value: name,
                modifiers: modifiers,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    parseBoolean: function() {
        if (this.tKind === 'boolean') {
            var value = this.t.value,
                line = this.t.line,
                lineEnd = this.t.line
            this.consume(1)
            return {
                kind: 'Boolean',
                value: value,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    parseNumber: function() {
        if (this.tKind === 'number') {
            var value = this.t.value,
                line = this.t.line,
                lineEnd = this.t.line
            this.consume(1)
            return {
                kind: 'Number',
                value: value,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    parseQuotedString: function() {
        if (this.tKind === 'string') {
            var value = this.t.value,
                line = this.t.line,
                lineEnd = this.t.line
            this.consume(1)
            return {
                kind: 'String',
                value: value,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    /**
     * Parse a mode block.
     */
    parseMode: function() {
        var name = this.t.value,
            line = this.t.line,
            lineEnd = this.t.line,
            content = []
        this.consume(1)

        while (this.tKind === 'raw') {
            content.push(this.t.value)
            lineEnd = this.t.line
            this.consume(1)
        }

        return {
            kind: 'Mode',
            name: name,
            value: content.join('\n'),
            line: line,
            lineEnd: lineEnd
        }
    },

    /**
     * parseBlock: Parse a block, which starts with an
     * indent and ends with a dedent.
     */
    parseBlock: function() {
        if (this.tKind === 'indent') {
            this.consume(1)
            this.indentLevel++

            var block = [],
                line = this.t.line,
                lineEnd = this.t.line
            while (this.tKind !== 'eof' && this.tKind !== 'dedent') {
                var node = this.parseToken(this.t)
                if (node) {
                    block.push(node)
                    lineEnd = node.lineEnd
                }
            }
            this.expect('dedent')
            this.consume(1)
            this.indentLevel--

            return {
                kind: 'Block',
                contents: block,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    parseList: function() {
        if (this.tKind === 'indent' &&
            this.tokens[this.index + 1].kind === 'begin-list-item') {
            this.consume(1)
            this.indentLevel++

            var elements = [],
                line = this.t.line,
                lineEnd = this.t.line,
                element
            while (element = this.parseListElement()) {
                elements.push(element)
                lineEnd = element.lineEnd
                if (this.tKind === 'newline') {
                    this.consume(1)
                    this.line++
                }
            }
            this.expect('dedent')
            this.consume(1)
            this.indentLevel--

            return {
                kind: 'List',
                elements: elements,
                line: line,
                lineEnd: lineEnd
            }
        }
    },

    parseListElement: function() {
        if (this.tKind === 'begin-list-item') {
            var body,
                line = this.t.line,
                lineEnd = line

            this.consume(1)

            if (this.tKind === 'indent') {
                // a block definition!

                body = this.parseList()

                if (!body) {
                    body = this.parseBlock()
                    lineEnd = body.lineEnd

                    // if every node in the body is a definition, then
                    // it's a Dictionary (otherwise, it's just some local
                    // definitions mixed with other nodes)
                    var isDictionary = true
                    for (var i = 0; i < body.contents.length; i++) {
                        if (body.contents[i].kind !== 'Definition') {
                            isDictionary = false
                            break
                        }
                    }
                    if (isDictionary) {
                        body = {
                            kind: 'Dictionary',
                            entries: body.contents,
                            line: body.line,
                            lineEnd: lineEnd
                        }
                    }
                }

            } else if (this.tKind === 'number') {
                body = this.parseNumber()
            } else if (this.tKind === 'string') {
                body = this.parseQuotedString()
            } else if (this.tKind === 'boolean') {
                body = this.parseBoolean()
            } else {
                body = []
                while (this.tKind !== 'eof' && this.tKind !== 'newline'
                    && this.tKind !== 'indent' && this.tKind !== 'dedent') {
                    var node = this.parseToken(this.t)
                    body.push(node)
                    lineEnd = node.lineEnd
                }
                if (body.length === 0) {
                    this.error('Definition of \'' + name.value + '\' is empty.')
                }
                body = {
                    kind: 'Block',
                    contents: body,
                    line: body[0].line,
                    lineEnd: lineEnd
                }
            }

            return {
                kind: 'ListElement',
                body: body,
                line: lineEnd,
                lineEnd: lineEnd
            }

        }
    },

    parseExtend: function() {
        if (this.seenNonExtend) {
            this.error('An extend statement can only appear at the top of a file, ' +
                        'before any other statements or content.', this.t.line)
        }
        if (this.indentLevel > 0) {
            this.error('An extend statement can only appear at the top level of ' +
                        'a file, not in an indented block.', this.t.line)
        }
        if (this.extendNode) {
            this.error('Only one extend statement allowed per file. ' +
                        'This file already extended file \'' +
                        this.extendNode.file.value + '\' on line ' +
                        this.extendNode.line + '.', this.t.line)
        }
        this.consume(1)
        this.expect('path')

        var path = this.t.value,
            line = this.t.line,
            lineEnd = line

        this.consume(1)

        this.extendNode = {
            kind: 'Extend',
            file: {
                kind: 'Path',
                value: path,
                line: line,
                lineEnd: lineEnd
            },
            line: line,
            lineEnd: lineEnd
        }
        return
    },

    parseImport: function() {
        if (this.seenNonImport) {
            this.error('Import statements must appear at the top of a file, ' +
                        'after the extend statement (if you have one) but ' +
                        'before any other statements or content.', this.t.line)
        }
        if (this.indentLevel > 0) {
            this.error('An import statement can only appear at the top level of ' +
                        'a file, not in an indented block.', this.t.line)
        }

        var line = this.t.line,
            lineEnd = line,
            file,
            alias

        this.consume(1)
        this.expect('path')
        file = {
            kind: 'Path',
            value: this.t.value,
            line: this.t.line,
            lineEnd: this.t.line
        }
        this.consume(1)
        this.expect('identifier')

        this.disallowModifiers = true
        alias = this.parseIdentifier()
        this.disallowModifiers = false

        this.importNodes.push({
            kind: 'Import',
            file: file,
            alias: alias,
            line: line,
            lineEnd: lineEnd
        })
        return
    },

    parseInclude: function() {
        this.consume(1)
        var line = this.t.line,
            lineEnd = line,
            context = null,
            included

        if (this.tKind === 'path') {
            included = {
                kind: 'Path',
                value: this.t.value,
                line: line,
                lineEnd: lineEnd
            }
            this.consume(1)
        } else {
            this.expect('identifier')
            included = this.parseIdentifier()
        }

        if (this.tKind === 'with') {
            this.consume(1)

            var block = this.parseBlock()
            lineEnd = block.lineEnd

            for (var i = 0; i < block.contents.length; i++) {
                var kind = block.contents[i].kind
                if (kind !== 'Definition' && kind !== 'Comment') {
                    this.error('Unexpected ' + block.contents[i].kind + ' node ' +
                        'found in \'with\' block. \'with\' blocks must contain ' +
                        'only definitions.', block.contents[i].line)
                }
            }
            context = {
                kind: 'Dictionary',
                entries: block.contents,
                line: block.line,
                lineEnd: lineEnd
            }
        }

        return {
            kind: 'Include',
            included: included,
            context: context,
            line: line,
            lineEnd: lineEnd
        }
    },

    parseFor: function() {
        var line = this.t.line,
            lineEnd = line,
            filters = null,
            iterator,
            data,
            body
        this.consume(1)

        this.expect('identifier')
        this.disallowModifiers = true
        iterator = this.parseIdentifier()
        this.disallowModifiers = false

        if (this.tKind === 'path') {
            data = {
                kind: 'Path',
                value: this.t.value,
                line: line,
                lineEnd: lineEnd
            }
            this.consume(1)
        } else {
            this.expect('identifier')
            data = this.parseIdentifier()
        }

        filters = this.parseFilterSequence() || null

        this.expect('indent')
        body = this.parseBlock()

        return {
            kind: 'For',
            iterator: iterator,
            data: data,
            filters: filters,
            body: body,
            line: line,
            lineEnd: body.lineEnd
        }
    },

    parseIf: function() {
        var line = this.t.line,
            lineEnd = line,
            predicate,
            negated = false,
            filters = null,
            thenCase = null,
            elifCases = [],
            elseCase = null

        this.consume(1)

        if (this.tKind === 'not') {
            negated = true
            this.consume(1)
        }

        this.expect('identifier')
        predicate = this.parseIdentifier()

        filters = this.parseFilterSequence() || null

        thenCase = this.parseBlock() || null

        while (this.tKind === 'begin-elif') {
            var elifLine = this.t.line,
                elifNegated = false,
                elifPredicate,
                elifFilters = null,
                elifThenCase = null
            this.consume(1)

            if (this.tKind === 'not') {
                elifNegated = true
                this.consume(1)
            }

            this.expect('identifier')
            elifPredicate = this.parseIdentifier()
            elifFilters = this.parseFilterSequence() || null
            elifThenCase = this.parseBlock() || null

            elifCases.push({
                kind: 'If',
                predicate: elifPredicate,
                negated: elifNegated,
                filters: elifFilters,
                thenCase: elifThenCase,
                elifCases: [],
                elseCase: null,
                line: elifLine,
                lineEnd: elifThenCase.lineEnd
            })
            lineEnd = elifThenCase.lineEnd
        }

        if (this.tKind === 'begin-else') {
            this.consume(1)
            elseCase = this.parseBlock() || null
            lineEnd = elseCase ? elseCase.lineEnd : lineEnd
        }

        return {
            kind: 'If',
            predicate: predicate,
            negated: negated,
            filters: filters,
            thenCase: thenCase,
            elifCases: elifCases,
            elseCase: elseCase,
            line: line,
            lineEnd: lineEnd
        }
    },

    parseComment: function() {
        var value = this.t.value,
            line = this.t.line,
            lineEnd = line

        this.consume(1)

        return {
            kind: 'Comment',
            value: value,
            line: line,
            lineEnd: lineEnd
        }
    },

    parseToken: function(token) {
        switch(token.kind) {
            case 'newline':
                this.consume(1)
                this.line++
                return
            case 'comment':
                return this.parseComment()
            case 'mode':
                return this.parseMode()
            case 'tag':
                return this.parseTag()
            case 'begin-definition':
                return this.parseDefinition()
            case 'begin-interpolation':
                return this.parseInterpolation()
            case 'text':
            case 'string':
                return this.parseText()
            case 'begin-for':
                return this.parseFor()
            case 'begin-if':
                return this.parseIf()
            case 'doctype':
                return this.parseDoctype()
            case 'include':
                return this.parseInclude()
            case 'import':
                return this.parseImport()
            case 'extend':
                return this.parseExtend()
            default:
                this.fail()
        }
    },

    parse: function() {
        var block = [],
            lineEnd = 1
        while (this.index < this.tokens.length) {
            var node = this.parseToken(this.t)
            if (node) {
                if ((!this.seenNonExtend || !this.seenNonImport) &&
                    node.kind !== 'Extend' && node.kind !== 'Comment') {
                    this.seenNonExtend = true
                    if (node.kind !== 'Import') {
                        this.seenNonImport = true
                    }
                }
                block.push(node)
                lineEnd = node.lineEnd
            }
        }
        return {
            kind: 'Document',
            extend: this.extendNode,
            imports: this.importNodes,
            contents: block,
            line: 1,
            lineEnd: lineEnd
        }
    }
}

function parse(tokens, code) {
    try {
        return (new Parser(tokens, code)).parse()
    } catch (e) {
        throw e
    }
}

module.exports.parse = parse